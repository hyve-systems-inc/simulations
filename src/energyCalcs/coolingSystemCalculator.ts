export interface TimeInterval {
  t0: number;
  t1: number;
  dt: number;
}

export interface AirProperties {
  density: number;
  specificHeat: number;
  thermalConductivity: number;
  viscosity: number;
  diffusivity: number;
}

export interface SystemParameters {
  // Basic respiration and thermal parameters
  rRef: number; // kg CO₂/kg·h (Reference respiration rate)
  k: number; // 1/°C (Temperature coefficient for respiration)
  tRef: number; // °C (Reference temperature)
  hResp: number; // J/kg CO₂ (Heat of respiration)
  mass: number; // kg (Total mass of product)
  specificHeat: number; // J/kg·°C (Specific heat capacity)
  tInitial: number; // °C (Initial temperature)
  tTarget: number; // °C (Target temperature)
  eRate: number; // J/°C·h (Energy rate coefficient)

  // Heat transfer parameters
  surfaceArea: number; // m² (Total surface area)
  heatTransferCoeff: number; // W/m²·K (Heat transfer coefficient)
  airVelocity: number; // m/s (Air velocity over product)
  relativeHumidity: number; // % (Relative humidity of air)
  ambientTemp: number; // °C (Ambient temperature)

  // Evaporative cooling parameters
  moistureContent: number; // kg water/kg dry matter (Initial moisture content)
  waterActivity: number; // dimensionless (Water activity of product, 0-1)
  surfaceWetness: number; // dimensionless (Surface wetness factor, 0-1)
  productPorosity: number; // dimensionless (Porosity of product, 0-1)
  massDiffusivity: number; // m²/s (Effective mass diffusivity)
  latentHeat: number; // J/kg (Latent heat of vaporization)

  // Air volume parameters
  roomVolume: number; // m³ (Total storage room volume)
  freeAirSpace: number; // m³ (Available air space = roomVolume - product volume)
  airExchangeRate: number; // 1/h (Air changes per hour)
  airflowRate?: number; // m³/h (Volumetric air flow rate)
  productStacking: number; // dimensionless (Stacking factor affecting air flow)
  ventEfficiency: number; // dimensionless (0-1, Ventilation efficiency factor)
}

interface AirVolumeMetrics {
  volumetricAirflow: number; // m³/h
  airResidenceTime: number; // h
  effectiveAirVolume: number; // m³
  airMoistureContent: number; // kg water/kg dry air
  airDensity: number; // kg/m³
}

interface EnergyFlows {
  respiration: number; // Heat generated by respiration (J)
  convection: number; // Heat removed by convective cooling (J)
  evaporation: number; // Heat removed by evaporation (J)
  airExchange: number; // Heat removed by air exchange (J)
  net: number; // Net energy change (J)
}

interface TimeSeriesPoint {
  time: number; // hours from start
  productTemperature: number; // °C
  moisture: number; // kg water/kg dry matter
  evaporationRate: number; // kg/s
  energyFlows: EnergyFlows;
}

interface CalculationResult {
  energyTotals: EnergyFlows;
  timeSeries: TimeSeriesPoint[];
  airMetrics: AirVolumeMetrics;
}

class CoolingSystemCalculator {
  private air: AirProperties;
  private params: SystemParameters;
  private time: TimeInterval;

  constructor(
    airProperties: AirProperties,
    systemParams: SystemParameters,
    timeInterval: TimeInterval
  ) {
    this.air = airProperties;
    this.params = systemParams;
    this.time = timeInterval;
  }

  public calculate(): CalculationResult {
    const steps = Math.ceil((this.time.t1 - this.time.t0) / this.time.dt);
    const timeSeries: TimeSeriesPoint[] = [
      {
        time: this.time.t0,
        productTemperature: this.params.tInitial,
        moisture: this.params.moistureContent,
        evaporationRate: 0,
        energyFlows: {
          respiration: 0,
          convection: 0,
          evaporation: 0,
          airExchange: 0,
          net: 0,
        },
      },
    ];

    let energyTotals: EnergyFlows = {
      respiration: 0,
      convection: 0,
      evaporation: 0,
      airExchange: 0,
      net: 0,
    };

    for (let i = 0; i < steps; i++) {
      const currentTime = this.time.t0 + (i + 1) * this.time.dt;
      const currentPoint = timeSeries[i];

      // Calculate each heat flow component for this timestep
      const respHeat = this.calculateRespirationHeat(
        currentPoint.productTemperature
      );
      const convHeat = this.calculateConvectiveHeat(
        currentPoint.productTemperature
      );
      const { evapHeat, evapRate } = this.calculateEvaporativeHeat(
        currentPoint.productTemperature
      );
      const airExchHeat = this.calculateAirExchangeHeat(
        currentPoint.productTemperature
      );

      // Net energy change is sum of all heat flows
      const netEnergy = respHeat - convHeat - evapHeat - airExchHeat;

      // Update running totals
      energyTotals.respiration += respHeat;
      energyTotals.convection += convHeat;
      energyTotals.evaporation += evapHeat;
      energyTotals.airExchange += airExchHeat;
      energyTotals.net += netEnergy;

      // Calculate temperature change (Q = m*c*ΔT)
      const tempChange =
        netEnergy / (this.params.mass * this.params.specificHeat);

      // Calculate moisture content change
      const moistureChange =
        (-evapRate * this.time.dt * 3600) / this.params.mass;

      // Record new state
      timeSeries.push({
        time: currentTime,
        productTemperature: currentPoint.productTemperature + tempChange,
        moisture: currentPoint.moisture + moistureChange,
        evaporationRate: evapRate,
        energyFlows: {
          respiration: respHeat,
          convection: convHeat,
          evaporation: evapHeat,
          airExchange: airExchHeat,
          net: netEnergy,
        },
      });
    }

    return {
      energyTotals,
      timeSeries,
      airMetrics: this.calculateAirMetrics(),
    };
  }

  private calculateRespirationHeat(temperature: number): number {
    // Q10 type temperature dependence for respiration rate (kg CO₂/kg·h)
    const respRate =
      this.params.rRef *
      Math.exp(this.params.k * (temperature - this.params.tRef));

    // Convert to heat generation (J) for the timestep
    // respRate (kg CO₂/kg·h) * mass (kg) * heat of resp (J/kg CO₂) * time (h)
    return respRate * this.params.mass * this.params.hResp * this.time.dt;
  }

  private calculateConvectiveHeat(temperature: number): number {
    // Basic Newton's law of cooling
    const deltaT = temperature - this.params.ambientTemp; // °C or K (same for difference)

    // Calculate heat transfer (W) with stacking factor adjustment
    // h (W/m²·K) * A (m²) * ΔT (K) * stacking factor
    const heatFlow =
      this.params.heatTransferCoeff *
      this.params.surfaceArea *
      deltaT *
      this.params.productStacking;

    // Convert to Joules for the timestep
    // W * seconds = J
    return heatFlow * this.time.dt * 3600;
  }

  private calculateEvaporativeHeat(temperature: number): {
    evapHeat: number; // J
    evapRate: number; // kg/s
  } {
    // Saturation vapor pressure at product temperature (Pa)
    const satVaporPressure =
      610.78 * Math.exp((17.27 * temperature) / (temperature + 237.3));

    // Actual vapor pressure in air (Pa)
    const airVaporPressure =
      satVaporPressure * (this.params.relativeHumidity / 100);

    // Vapor pressure deficit (Pa)
    const vpd = satVaporPressure * this.params.waterActivity - airVaporPressure;

    // Mass transfer coefficient from heat transfer coefficient using Lewis analogy
    const massTransferCoeff =
      this.params.heatTransferCoeff /
      (this.air.density * this.air.specificHeat);

    // Evaporation rate (kg/s)
    const evapRate =
      ((massTransferCoeff *
        this.params.surfaceArea *
        this.params.surfaceWetness *
        vpd) /
        (461.5 * (temperature + 273.15))) * // Gas constant for water vapor
      this.params.productStacking;

    // Heat removal rate (W) converted to J for timestep
    const evapHeat = evapRate * this.params.latentHeat * this.time.dt * 3600;

    return { evapHeat, evapRate };
  }

  private calculateAirExchangeHeat(temperature: number): number {
    // Basic sensible heat exchange with ventilation air
    const deltaT = temperature - this.params.ambientTemp;

    // Air flow rate (m³/h) with ventilation efficiency
    const effectiveAirflow =
      this.calculateAirflow() * this.params.ventEfficiency;

    // Heat transfer rate (J/h)
    // ṁ (kg/h) * cp (J/kg·K) * ΔT (K)
    const heatTransferRate =
      effectiveAirflow * this.air.density * this.air.specificHeat * deltaT;

    // Convert to Joules for timestep
    return heatTransferRate * this.time.dt;
  }

  private calculateAirflow(): number {
    // Calculate volumetric airflow (m³/h)
    if (this.params.airflowRate !== undefined) {
      return this.params.airflowRate;
    }

    // Based on air exchange rate
    return this.params.roomVolume * this.params.airExchangeRate;
  }

  private calculateAirMetrics(): AirVolumeMetrics {
    const volumetricAirflow = this.calculateAirflow();
    const effectiveAirVolume =
      this.params.freeAirSpace * this.params.ventEfficiency;
    const airResidenceTime = effectiveAirVolume / volumetricAirflow;

    // Calculate air moisture content using psychrometric relationship
    const satPressure =
      610.78 *
      Math.exp(
        (17.27 * this.params.ambientTemp) / (this.params.ambientTemp + 237.3)
      );
    const partialPressure = satPressure * (this.params.relativeHumidity / 100);
    const airMoistureContent =
      (0.622 * partialPressure) / (101325 - partialPressure);

    return {
      volumetricAirflow,
      airResidenceTime,
      effectiveAirVolume,
      airMoistureContent,
      airDensity: this.air.density,
    };
  }
}

export default CoolingSystemCalculator;
